<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸‰å¥åŠÂ·ç»ˆææ··åˆéŸ³æ•ˆç³»ç»Ÿ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: "Microsoft YaHei", sans-serif;
            background: linear-gradient(135deg, #000000, #0c0b1d, #2d1b69);
            color: white;
            min-height: 100vh;
            padding: 20px;
            touch-action: manipulation;
        }
        .container { max-width: 500px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 20px; padding: 15px; }
        h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #ff00cc, #3333ff, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255, 0, 204, 0.3);
        }
        
        /* æ··åˆæ§åˆ¶åŒº */
        .hybrid-control {
            background: rgba(255, 0, 204, 0.05);
            border: 2px solid rgba(255, 0, 204, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            position: relative;
        }
        .hybrid-control::before {
            content: 'ğŸ›ï¸';
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 2rem;
            opacity: 0.5;
        }
        
        /* æ³¢å½¢å¯è§†åŒ– */
        .wave-display {
            height: 80px;
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            margin: 15px 0;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .real-wave {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 50%;
            background: linear-gradient(to top, 
                transparent,
                rgba(0, 204, 255, 0.1),
                rgba(0, 204, 255, 0.3)
            );
            border-bottom: 1px solid rgba(0, 204, 255, 0.2);
        }
        .synth-wave {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50%;
            background: linear-gradient(to bottom, 
                transparent,
                rgba(255, 0, 204, 0.1),
                rgba(255, 0, 204, 0.3)
            );
        }
        .wave-label {
            position: absolute;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 3px;
            top: 5px;
            right: 5px;
            background: rgba(0,0,0,0.5);
        }
        .wave-label.real {
            color: #00ccff;
            top: 5px;
        }
        .wave-label.synth {
            color: #ff00cc;
            bottom: 5px;
            top: auto;
        }
        
        /* æŒ‰é’®ç½‘æ ¼ */
        .button-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin: 20px 0;
        }
        .sound-btn {
            padding: 25px 10px;
            border-radius: 12px;
            border: 2px solid;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }
        .sound-btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            transform: translate(-50%, -50%);
            transition: width 0.3s, height 0.3s;
        }
        .sound-btn:active::after {
            width: 100px;
            height: 100px;
        }
        .sound-btn.real {
            border-color: #00ccff;
            background: linear-gradient(135deg, rgba(0,204,255,0.2), rgba(0,204,255,0.05));
        }
        .sound-btn.hybrid {
            border-color: #ff00cc;
            background: linear-gradient(135deg, rgba(255,0,204,0.2), rgba(255,0,204,0.05));
        }
        .sound-btn.synth {
            border-color: #33ff33;
            background: linear-gradient(135deg, rgba(51,255,51,0.2), rgba(51,255,51,0.05));
        }
        .sound-btn.auto {
            border-color: #ffcc00;
            background: linear-gradient(135deg, rgba(255,204,0,0.2), rgba(255,204,0,0.05));
            grid-column: span 2;
        }
        
        /* åŠ è½½çŠ¶æ€ */
        .load-status {
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            text-align: center;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .load-status.success {
            background: rgba(0,200,100,0.1);
            border-color: #00cc66;
        }
        .load-status.loading {
            background: rgba(255,204,0,0.1);
            border-color: #ffcc00;
        }
        .load-status.error {
            background: rgba(255,50,50,0.1);
            border-color: #ff3333;
        }
        
        /* æ§åˆ¶æ»‘å— */
        .slider-group {
            margin: 15px 0;
        }
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.95rem;
        }
        .slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            border-radius: 4px;
            outline: none;
        }
        .slider.mix {
            background: linear-gradient(90deg, #00ccff, #ff00cc);
        }
        .slider.delay {
            background: linear-gradient(90deg, #3333ff, #33ff33);
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            border: 2px solid;
            box-shadow: 0 0 10px currentColor;
        }
        .slider.mix::-webkit-slider-thumb {
            border-color: #ff00cc;
        }
        .slider.delay::-webkit-slider-thumb {
            border-color: #33ff33;
        }
        
        /* é¢„è®¾æŒ‰é’® */
        .preset-buttons {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }
        .preset-btn {
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.05);
            color: white;
            cursor: pointer;
            font-size: 0.9rem;
            text-align: center;
        }
        .preset-btn.active {
            background: rgba(255, 0, 204, 0.2);
            border-color: #ff00cc;
        }
        
        @media (max-width: 600px) {
            h1 { font-size: 1.5rem; }
            .sound-btn { padding: 20px 8px; font-size: 1rem; }
            .button-grid { gap: 10px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸšï¸ çœŸå®å½•éŸ³ + åˆæˆçˆ†ç ´æ··åˆå¼•æ“</h1>
            <p style="color: #a0d2ff; opacity: 0.9;">9722.wav çœŸå®é”£å£° Ã— çˆ†è£‚åˆæˆéŸ³æ•ˆ</p>
        </header>
        
        <!-- åŠ è½½çŠ¶æ€ -->
        <div class="load-status" id="loadStatus">
            ğŸµ æ­£åœ¨åˆå§‹åŒ–æ··åˆéŸ³é¢‘å¼•æ“...
        </div>
        
        <!-- æ³¢å½¢å¯è§†åŒ– -->
        <div class="wave-display">
            <div class="real-wave" id="realWave"></div>
            <div class="synth-wave" id="synthWave"></div>
            <div class="wave-label real">çœŸå®å½•éŸ³æ³¢å½¢</div>
            <div class="wave-label synth">åˆæˆçˆ†ç ´æ³¢å½¢</div>
        </div>
        
        <!-- æ··åˆæ§åˆ¶åŒº -->
        <div class="hybrid-control">
            <h3 style="margin: 0 0 15px 0; color: #ff00cc;">ğŸ›ï¸ æ··åˆæ§åˆ¶é¢æ¿</h3>
            
            <div class="slider-group">
                <div class="slider-label">
                    <span>ğŸ”€ çœŸå®/åˆæˆæ··åˆæ¯”</span>
                    <span id="mixValue">50%çœŸå® / 50%åˆæˆ</span>
                </div>
                <input type="range" min="0" max="100" value="50" class="slider mix" id="mixSlider">
                <div style="display: flex; justify-content: space-between; font-size: 0.8rem; margin-top: 5px;">
                    <span style="color: #00ccff;">çº¯çœŸå®</span>
                    <span style="color: #ff00cc;">çº¯åˆæˆ</span>
                </div>
            </div>
            
            <div class="slider-group">
                <div class="slider-label">
                    <span>â±ï¸ åˆæˆå»¶è¿Ÿæ—¶é—´</span>
                    <span id="delayValue">15ms</span>
                </div>
                <input type="range" min="0" max="100" value="15" class="slider delay" id="delaySlider">
                <div style="display: flex; justify-content: space-between; font-size: 0.8rem; margin-top: 5px;">
                    <span>åŒæ—¶å‘å£°</span>
                    <span>å»¶è¿Ÿ50ms</span>
                </div>
            </div>
            
            <!-- é¢„è®¾æŒ‰é’® -->
            <div class="preset-buttons">
                <button class="preset-btn" data-preset="realistic">ğŸ¤ çœŸå®ä¸ºä¸»</button>
                <button class="preset-btn active" data-preset="balanced">âš–ï¸ å¹³è¡¡æ··åˆ</button>
                <button class="preset-btn" data-preset="explosive">ğŸ’¥ çˆ†è£‚ä¸ºä¸»</button>
            </div>
        </div>
        
        <!-- æŒ‰é’®ç½‘æ ¼ -->
        <div class="button-grid">
            <button class="sound-btn real" id="realBtn">
                <span style="font-size: 1.5rem;">ğŸ¯</span>
                çº¯çœŸå®éŸ³æ•ˆ
                <small>9722.wavåŸå£°</small>
            </button>
            
            <button class="sound-btn hybrid" id="hybridBtn">
                <span style="font-size: 1.5rem;">âš¡</span>
                æ··åˆçˆ†è£‚éŸ³
                <small>çœŸå®+åˆæˆ</small>
            </button>
            
            <button class="sound-btn synth" id="synthBtn">
                <span style="font-size: 1.5rem;">ğŸ’£</span>
                çº¯åˆæˆçˆ†ç ´
                <small>ç‰©ç†å»ºæ¨¡</small>
            </button>
            
            <button class="sound-btn auto" id="autoBtn">
                <span style="font-size: 1.5rem;">ğŸ¬</span>
                ä¸‰å¥åŠè‡ªåŠ¨æ¼”ç¤º
                <small>ä½“éªŒå®Œæ•´æ•ˆæœ</small>
            </button>
        </div>
        
        <!-- çŠ¶æ€ä¿¡æ¯ -->
        <div class="load-status" id="statusInfo">
            ğŸ”Š ç‚¹å‡»æŒ‰é’®å¼€å§‹ä½“éªŒæ··åˆéŸ³æ•ˆ
        </div>
    </div>

    <script>
        // ç»ˆææ··åˆéŸ³é¢‘å¼•æ“
        class UltimateHybridEngine {
            constructor() {
                this.audioContext = null;
                this.realAudioBuffer = null;  // 9722.wav
                this.synthBuffers = {};       // åˆæˆéŸ³æ•ˆç¼“å­˜
                this.isRealLoaded = false;
                this.isInitialized = false;
                
                // æ··åˆå‚æ•°
                this.mixRatio = 0.5;          // 0=çº¯åˆæˆ 1=çº¯çœŸå®
                this.synthDelay = 0.015;      // åˆæˆå»¶è¿Ÿï¼ˆç§’ï¼‰
                this.currentPreset = 'balanced';
                
                // éŸ³é¢‘èŠ‚ç‚¹ç¼“å­˜
                this.realSource = null;
                this.synthSource = null;
                this.realGain = null;
                this.synthGain = null;
                
                // å¯è§†åŒ–æ•°æ®
                this.visualizationData = {
                    real: new Array(100).fill(0),
                    synth: new Array(100).fill(0)
                };
            }
            
            async initialize() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.updateStatus('éŸ³é¢‘å¼•æ“å¯åŠ¨æˆåŠŸï¼Œæ­£åœ¨åŠ è½½çœŸå®å½•éŸ³...', 'loading');
                    
                    // åŒæ—¶åŠ è½½çœŸå®å½•éŸ³å’Œç”ŸæˆåˆæˆéŸ³æ•ˆ
                    await Promise.all([
                        this.loadRealAudio(),
                        this.generateSynthSounds()
                    ]);
                    
                    this.isInitialized = true;
                    this.updateStatus('âœ… æ··åˆéŸ³é¢‘å¼•æ“å°±ç»ªï¼ç‚¹å‡»æŒ‰é’®ä½“éªŒ', 'success');
                    this.startVisualization();
                    
                    return true;
                } catch (error) {
                    console.error('åˆå§‹åŒ–å¤±è´¥:', error);
                    this.updateStatus(`âŒ åˆå§‹åŒ–å¤±è´¥: ${error.message}`, 'error');
                    return false;
                }
            }
            
            // åŠ è½½çœŸå®å½•éŸ³ 9722.wav
            async loadRealAudio() {
                try {
                    this.updateStatus('æ­£åœ¨åŠ è½½ 9722.wav çœŸå®é”£å£°...', 'loading');
                    
                    // å°è¯•å¤šç§åŠ è½½æ–¹å¼
                    let response;
                    const urls = [
                        '9722.wav',
                        './9722.wav',
                        window.location.href.split('/').slice(0, -1).join('/') + '/9722.wav'
                    ];
                    
                    for (const url of urls) {
                        try {
                            response = await fetch(url);
                            if (response.ok) break;
                        } catch (e) {
                            continue;
                        }
                    }
                    
                    if (!response || !response.ok) {
                        throw new Error('æ‰¾ä¸åˆ° 9722.wav æ–‡ä»¶');
                    }
                    
                    const arrayBuffer = await response.arrayBuffer();
                    this.realAudioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                    this.isRealLoaded = true;
                    
                    console.log('çœŸå®å½•éŸ³åŠ è½½æˆåŠŸ:', this.realAudioBuffer);
                    this.updateStatus(`âœ… çœŸå®å½•éŸ³åŠ è½½æˆåŠŸï¼æ—¶é•¿: ${this.realAudioBuffer.duration.toFixed(2)}ç§’`, 'success');
                    
                } catch (error) {
                    console.error('çœŸå®å½•éŸ³åŠ è½½å¤±è´¥:', error);
                    this.updateStatus('âš ï¸ çœŸå®å½•éŸ³åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨åˆæˆéŸ³æ•ˆæ›¿ä»£', 'error');
                    
                    // ç”Ÿæˆæ›¿ä»£çš„çœŸå®æ„ŸéŸ³æ•ˆ
                    this.generateRealisticAlternative();
                }
            }
            
            // ç”Ÿæˆæ›¿ä»£çš„çœŸå®æ„ŸéŸ³æ•ˆ
            generateRealisticAlternative() {
                const duration = 3.0;
                const buffer = this.audioContext.createBuffer(2, 
                    this.audioContext.sampleRate * duration, 
                    this.audioContext.sampleRate);
                
                const left = buffer.getChannelData(0);
                const right = buffer.getChannelData(1);
                
                // åˆ›å»ºçœŸå®æ„Ÿé”£å£°
                for (let i = 0; i < buffer.length; i++) {
                    const t = i / this.audioContext.sampleRate;
                    const envelope = Math.exp(-t * 2) * (1 - Math.exp(-t * 50));
                    
                    // ä¸»é¢‘ç‡
                    const freq = 220 * Math.exp(-t * 0.5);
                    const wave = Math.sin(t * freq * Math.PI * 2) * envelope;
                    
                    // æ³›éŸ³
                    const overtone1 = Math.sin(t * freq * 3 * Math.PI * 2) * envelope * 0.3;
                    const overtone2 = Math.sin(t * freq * 5 * Math.PI * 2) * envelope * 0.1;
                    
                    // ç¬æ€å™ªå£°
                    const noise = t < 0.05 ? (Math.random() * 2 - 1) * (0.1 - t * 2) : 0;
                    
                    left[i] = (wave + overtone1 + overtone2 + noise) * 0.6;
                    right[i] = left[i] * 0.9;
                }
                
                this.realAudioBuffer = buffer;
                this.isRealLoaded = true;
            }
            
            // ç”Ÿæˆåˆæˆçˆ†ç ´éŸ³æ•ˆ
            generateSynthSounds() {
                const types = ['explosion', 'impact', 'deep', 'sharp'];
                
                types.forEach(type => {
                    const buffer = this.createSynthSound(type);
                    this.synthBuffers[type] = buffer;
                });
                
                console.log('åˆæˆéŸ³æ•ˆç”Ÿæˆå®Œæˆ');
            }
            
            createSynthSound(type) {
                const duration = type === 'deep' ? 3.5 : 2.0;
                const buffer = this.audioContext.createBuffer(2, 
                    this.audioContext.sampleRate * duration, 
                    this.audioContext.sampleRate);
                
                const left = buffer.getChannelData(0);
                const right = buffer.getChannelData(1);
                
                for (let i = 0; i < buffer.length; i++) {
                    const t = i / this.audioContext.sampleRate;
                    
                    let sample = 0;
                    
                    switch(type) {
                        case 'explosion': // çˆ†è£‚éŸ³
                            sample = this.createExplosionSound(t);
                            break;
                        case 'impact': // å†²å‡»éŸ³
                            sample = this.createImpactSound(t);
                            break;
                        case 'deep': // æ·±æ²‰éŸ³
                            sample = this.createDeepSound(t);
                            break;
                        case 'sharp': // å°–é”éŸ³
                            sample = this.createSharpSound(t);
                            break;
                    }
                    
                    left[i] = sample;
                    right[i] = sample * (0.8 + Math.sin(t) * 0.2);
                }
                
                return buffer;
            }
            
            createExplosionSound(t) {
                const attack = Math.min(t * 100, 1);
                const decay = Math.exp(-t * 3);
                const envelope = attack * decay;
                
                // ä½é¢‘ä¸»ä½“
                const freq = 80 * Math.exp(-t * 2);
                const main = Math.sin(t * freq * Math.PI * 2) * envelope;
                
                // é«˜é¢‘çˆ†è£‚
                const burst = t < 0.1 ? Math.sin(t * 800 * Math.PI * 2) * (0.1 - t) * 10 : 0;
                
                // å™ªå£°å±‚
                const noise = t < 0.2 ? (Math.random() * 2 - 1) * Math.exp(-t * 20) : 0;
                
                return (main * 0.7 + burst * 0.2 + noise * 0.1) * 0.8;
            }
            
            createImpactSound(t) {
                const envelope = Math.exp(-t * 8) * (1 - Math.exp(-t * 200));
                const freq = 300 * Math.exp(-t * 4);
                const main = Math.sin(t * freq * Math.PI * 2) * envelope;
                
                // ç‚¹å‡»ç¬æ€
                const click = t < 0.005 ? Math.sin(t * 2000 * Math.PI * 2) * (1 - t * 200) : 0;
                
                return (main * 0.8 + click * 0.2) * 0.9;
            }
            
            createDeepSound(t) {
                const envelope = Math.exp(-t * 1.5);
                const freq = 110 * (1 - t * 0.3);
                const main = Math.sin(t * freq * Math.PI * 2) * envelope;
                
                // æ³›éŸ³
                const overtones = [2, 3, 4, 5].reduce((sum, mult) => {
                    return sum + Math.sin(t * freq * mult * Math.PI * 2) * envelope * (0.5 / mult);
                }, 0);
                
                return (main * 0.6 + overtones * 0.4) * 0.7;
            }
            
            createSharpSound(t) {
                const envelope = Math.exp(-t * 6);
                const freq = 600 + Math.sin(t * 10) * 100;
                const main = Math.sin(t * freq * Math.PI * 2) * envelope;
                
                // é‡‘å±æ„Ÿ
                const metal = Math.sin(t * 1200 * Math.PI * 2) * envelope * 0.3;
                
                return (main * 0.7 + metal * 0.3) * 0.8;
            }
            
            // æ’­æ”¾æ··åˆéŸ³æ•ˆ
            playHybridSound(type = 'balanced') {
                if (!this.isInitialized) {
                    this.initialize().then(() => this.playHybridSound(type));
                    return;
                }
                
                this.stopAllSounds();
                
                const now = this.audioContext.currentTime;
                const delay = this.synthDelay;
                
                // è®¡ç®—éŸ³é‡
                const realVolume = this.mixRatio;
                const synthVolume = 1 - this.mixRatio;
                
                // æ’­æ”¾çœŸå®å½•éŸ³
                if (this.isRealLoaded && realVolume > 0.01) {
                    this.realSource = this.audioContext.createBufferSource();
                    this.realSource.buffer = this.realAudioBuffer;
                    
                    this.realGain = this.audioContext.createGain();
                    this.realGain.gain.setValueAtTime(realVolume, now);
                    
                    this.realSource.connect(this.realGain);
                    this.realGain.connect(this.audioContext.destination);
                    
                    this.realSource.start(now);
                    
                    // æ›´æ–°å¯è§†åŒ–
                    this.updateVisualization('real', 0.5 + realVolume * 0.5);
                }
                
                // æ’­æ”¾åˆæˆéŸ³æ•ˆï¼ˆå¯é€‰å»¶è¿Ÿï¼‰
                if (synthVolume > 0.01) {
                    setTimeout(() => {
                        const synthType = this.getSynthTypeForPreset(type);
                        this.synthSource = this.audioContext.createBufferSource();
                        this.synthSource.buffer = this.synthBuffers[synthType];
                        
                        this.synthGain = this.audioContext.createGain();
                        this.synthGain.gain.setValueAtTime(synthVolume, now + delay);
                        
                        this.synthSource.connect(this.synthGain);
                        this.synthGain.connect(this.audioContext.destination);
                        
                        this.synthSource.start(now + delay);
                        
                        // æ›´æ–°å¯è§†åŒ–
                        this.updateVisualization('synth', 0.5 + synthVolume * 0.5);
                    }, delay * 1000);
                }
                
                // æ›´æ–°çŠ¶æ€
                const mixText = this.mixRatio > 0.66 ? 'çœŸå®ä¸ºä¸»' : 
                              this.mixRatio < 0.33 ? 'åˆæˆä¸ºä¸»' : 'å¹³è¡¡æ··åˆ';
                this.updateStatus(`ğŸ”Š æ’­æ”¾ä¸­: ${mixText} (${Math.round(this.mixRatio*100)}%çœŸå®)`, 'success');
            }
            
            // æ’­æ”¾çº¯çœŸå®éŸ³æ•ˆ
            playRealOnly() {
                if (!this.isRealLoaded) {
                    this.updateStatus('âŒ çœŸå®å½•éŸ³æœªåŠ è½½', 'error');
                    return;
                }
                
                this.stopAllSounds();
                
                this.realSource = this.audioContext.createBufferSource();
                this.realSource.buffer = this.realAudioBuffer;
                this.realSource.connect(this.audioContext.destination);
                this.realSource.start();
                
                this.updateVisualization('real', 1.0);
                this.updateStatus('ğŸ¯ æ’­æ”¾çº¯çœŸå®å½•éŸ³ (9722.wav)', 'success');
            }
            
            // æ’­æ”¾çº¯åˆæˆéŸ³æ•ˆ
            playSynthOnly(type = 'explosion') {
                this.stopAllSounds();
                
                this.synthSource = this.audioContext.createBufferSource();
                this.synthSource.buffer = this.synthBuffers[type];
                this.synthSource.connect(this.audioContext.destination);
                this.synthSource.start();
                
                this.updateVisualization('synth', 1.0);
                this.updateStatus('ğŸ’£ æ’­æ”¾çº¯åˆæˆçˆ†ç ´éŸ³æ•ˆ', 'success');
            }
            
            // åœæ­¢æ‰€æœ‰å£°éŸ³
            stopAllSounds() {
                if (this.realSource) {
                    try { this.realSource.stop(); } catch(e) {}
                    this.realSource = null;
                }
                if (this.synthSource) {
                    try { this.synthSource.stop(); } catch(e) {}
                    this.synthSource = null;
                }
            }
            
            // ä¸‰å¥åŠè‡ªåŠ¨æ¼”ç¤º
            autoDemo() {
                if (!this.isInitialized) {
                    this.initialize();
                    setTimeout(() => this.autoDemo(), 1000);
                    return;
                }
                
                this.updateStatus('ğŸ¬ å¼€å§‹ä¸‰å¥åŠè‡ªåŠ¨æ¼”ç¤º...', 'loading');
                
                // æ¼”ç¤ºåºåˆ—
                const sequence = [
                    { type: 'real', delay: 0, desc: 'ç¬¬ä¸€å¥ï¼šçœŸå®é”£å£°' },
                    { type: 'real', delay: 1500, desc: 'ç¬¬äºŒå¥ï¼šçœŸå®é”£å£°' },
                    { type: 'hybrid', preset: 'balanced', delay: 3000, desc: 'ç¬¬ä¸‰å¥ï¼šæ··åˆéŸ³æ•ˆ' },
                    { type: 'hybrid', preset: 'explosive', delay: 4500, desc: 'åŠå¥ï¼šçˆ†è£‚ç»“å°¾ï¼' }
                ];
                
                let completed = 0;
                sequence.forEach((item, index) => {
                    setTimeout(() => {
                        if (item.type === 'real') {
                            this.playRealOnly();
                        } else {
                            this.currentPreset = item.preset;
                            this.applyPreset(item.preset);
                            this.playHybridSound(item.preset);
                        }
                        
                        this.updateStatus(item.desc, 'success');
                        completed++;
                        
                        // å…¨éƒ¨å®Œæˆ
                        if (completed === sequence.length) {
                            setTimeout(() => {
                                this.updateStatus('âœ… æ¼”ç¤ºå®Œæˆï¼ç°åœ¨å¯ä»¥è‡ªç”±ä½“éªŒ', 'success');
                            }, 2000);
                        }
                    }, item.delay);
                });
            }
            
            // é¢„è®¾æ˜ å°„
            getSynthTypeForPreset(preset) {
                const mapping = {
                    'realistic': 'deep',
                    'balanced': 'explosion',
                    'explosive': 'impact'
                };
                return mapping[preset] || 'explosion';
            }
            
            // åº”ç”¨é¢„è®¾
            applyPreset(preset) {
                this.currentPreset = preset;
                
                switch(preset) {
                    case 'realistic':
                        this.mixRatio = 0.8;  // 80%çœŸå®
                        this.synthDelay = 0.01; // 10mså»¶è¿Ÿ
                        break;
                    case 'balanced':
                        this.mixRatio = 0.5;  // 50%çœŸå®
                        this.synthDelay = 0.015; // 15mså»¶è¿Ÿ
                        break;
                    case 'explosive':
                        this.mixRatio = 0.2;  // 20%çœŸå®
                        this.synthDelay = 0.02; // 20mså»¶è¿Ÿ
                        break;
                }
                
                // æ›´æ–°UI
                document.getElementById('mixSlider').value = this.mixRatio * 100;
                document.getElementById('delaySlider').value = this.synthDelay * 1000;
                this.updateMixValue();
                this.updateDelayValue();
                
                // æ›´æ–°é¢„è®¾æŒ‰é’®çŠ¶æ€
                document.querySelectorAll('.preset-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.preset === preset) {
                        btn.classList.add('active');
                    }
                });
            }
            
            // æ›´æ–°æ··åˆæ¯”ä¾‹æ˜¾ç¤º
            updateMixValue() {
                const realPercent = Math.round(this.mixRatio * 100);
                const synthPercent = 100 - realPercent;
                document.getElementById('mixValue').textContent = 
                    `${realPercent}%çœŸå® / ${synthPercent}%åˆæˆ`;
            }
            
            // æ›´æ–°å»¶è¿Ÿæ˜¾ç¤º
            updateDelayValue() {
                document.getElementById('delayValue').textContent = 
                    `${Math.round(this.synthDelay * 1000)}ms`;
            }
            
            // æ›´æ–°çŠ¶æ€
            updateStatus(message, type = 'info') {
                const statusEl = document.getElementById('statusInfo');
                const loadStatus = document.getElementById('loadStatus');
                
                statusEl.textContent = message;
                statusEl.className = `load-status ${type}`;
                
                if (type !== 'info') {
                    loadStatus.textContent = message;
                    loadStatus.className = `load-status ${type}`;
                }
            }
            
            // æ›´æ–°å¯è§†åŒ–
            updateVisualization(type, intensity) {
                const wave = document.getElementById(type === 'real' ? 'realWave' : 'synthWave');
                wave.style.height = `${intensity * 100}%`;
                wave.style.opacity = intensity;
                
                // æ·»åŠ æ³¢åŠ¨æ•ˆæœ
                wave.style.transform = `scaleY(${1 + Math.sin(Date.now()/200) * 0.2})`;
            }
            
            // å¯åŠ¨å¯è§†åŒ–å¾ªç¯
            startVisualization() {
                const animate = () => {
                    // å®æ—¶æ›´æ–°æ³¢å½¢
                    const now = Date.now();
                    const realIntensity = 0.3 + Math.sin(now / 500) * 0.1;
                    const synthIntensity = 0.3 + Math.cos(now / 700) * 0.1;
                    
                    this.updateVisualization('real', realIntensity);
                    this.updateVisualization('synth', synthIntensity);
                    
                    requestAnimationFrame(animate);
                };
                
                animate();
            }
        }
        
        // åˆå§‹åŒ–å¼•æ“
        const hybridEngine = new UltimateHybridEngine();
        
        // é¡µé¢åŠ è½½
        document.addEventListener('DOMContentLoaded', () => {
            // ç«‹å³åˆå§‹åŒ–
            hybridEngine.initialize();
            
            // ç»‘å®šæ··åˆæ§åˆ¶
            document.getElementById('mixSlider').addEventListener('input', (e) => {
                hybridEngine.mixRatio = parseInt(e.target.value) / 100;
                hybridEngine.updateMixValue();
            });
            
            document.getElementById('delaySlider').addEventListener('input', (e) => {
                hybridEngine.synthDelay = parseInt(e.target.value) / 1000;
                hybridEngine.updateDelayValue();
            });
            
            // é¢„è®¾æŒ‰é’®
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const preset = this.dataset.preset;
                    hybridEngine.applyPreset(preset);
                });
            });
            
            // éŸ³æ•ˆæŒ‰é’®
            document.getElementById('realBtn').addEventListener('click', () => {
                hybridEngine.playRealOnly();
            });
            
            document.getElementById('hybridBtn').addEventListener('click', () => {
                hybridEngine.playHybridSound(hybridEngine.currentPreset);
            });
            
            document.getElementById('synthBtn').addEventListener('click', () => {
                hybridEngine.playSynthOnly('explosion');
            });
            
            document.getElementById('autoBtn').addEventListener('click', () => {
                hybridEngine.autoDemo();
            });
            
            // åˆå§‹åº”ç”¨å¹³è¡¡é¢„è®¾
            hybridEngine.applyPreset('balanced');
            
            // è§¦æ‘¸è§£é”éŸ³é¢‘
            document.body.addEventListener('touchstart', function unlockAudio() {
                if (hybridEngine.audioContext && hybridEngine.audioContext.state === 'suspended') {
                    hybridEngine.audioContext.resume();
                }
                this.removeEventListener('touchstart', unlockAudio);
            });
        });
        
        // é˜²æ­¢å±å¹•ä¼‘çœ 
        if ('wakeLock' in navigator) {
            navigator.wakeLock.request('screen').catch(() => {});
        }
    </script>
</body>
</html>
